fn main() {
    for i in 0..=19 {
        println!("{}: {}", i, Solution::num_trees(i));
    }
}

/// f(0) = 1\
/// f(1) = 1\
/// f(2) = 2\
/// f(3) = 5\
/// f(4) = 14\
/// f(5) = 42\
/// f(6) = 132\
/// f(7) = 429
///
/// 以 ```n=4``` 为例，可以看作分别以1、2、3、4为根节点的所有情况的总和。
/// 以1为根节点可以分解为，左边为0个节点，共有f(0)种可能；右边为3个节点，共有f(3)种可能；所以总共有 f(0) * f(3) 种可能。\
/// 以2为根节点可以分解为，左边为1个节点，共有f(1)种可能；右边为2个节点，共有f(2)种可能；所以总共有 f(1) * f(2) 种可能。\
/// 以3为根节点可以分解为，左边为2个节点，共有f(2)种可能；右边为1个节点，共有f(1)种可能；所以总共有 f(2) * f(1) 种可能。\
/// 以4为根节点可以分解为，左边为3个节点，共有f(3)种可能；右边为0个节点，共有f(0)种可能；所以总共有 f(3) * f(0) 种可能。\
/// 所以 f(4) = f(0)*f(3) + f(1)*f(2) + f(2)*f(1) + f(3)*f(0)
struct Solution;

impl Solution {
    pub fn num_trees(n: i32) -> i32 {
        let n = n as usize;
        let mut memo = vec![];
        for i in 0..=n {
            if i == 0 {
                memo.push(1);
            } else {
                let mut s = 0;
                for j in 0..i {
                    s += memo[j] * memo[i - j - 1];
                }
                memo.push(s);
            }
        }
        memo[n]
    }
}
